import hashlib #For making a hash value of a file and to compare that value to other hash values of values of malicious files we know of.
import os #Helps the robot move around folders and check files.
import sys #sys: Helps the robot understand what files you told it to check.
import urllib.request #urllib.request: Lets the robot download the newest list of bad fingerprints from the internet.
import shutil #to move the file into the quarantine folder

#URL to fetch the latest malicious signatures:
SIGNATURES_URL = "https://example.com/malicious_hashes.txt"
QUARANTINE_FOLDER = "quarantine"

#List of known malicious file hashes (example SHA256 hashes):
malicious_signatures = [
    "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855", #Random hashes to illustrate. #SHA256 of empty file
    #Add more SHA256 hashes here
]

#Fetches the latest malicious signatures:
def fetch_online_signatures(url):
    try:
        print(f"Fetching latest malicious signatures from {url} ...")
        with urllib.request.urlopen(url, timeout=10) as response:
            data = response.read().decode('utf-8')
        #Extract hashes line-by-line, remove empty lines and whitespace
        hashes = [line.strip() for line in data.splitlines() if line.strip()]
        print(f"Fetched {len(hashes)} signatures from the internet.")
        return hashes
    except Exception as e:
        print(f"[Warning] Could not fetch online signatures: {e}")
        return []
    
#Updates the latest malicious signatures:
def update_signatures(local_signatures):
    online_signatures = fetch_online_signatures(SIGNATURES_URL)
    combined = set(local_signatures)  #Use a set to avoid duplicates
    combined.update(online_signatures)
    print(f"Total signatures after update: {len(combined)}")
    return list(combined)

#This takes a file and creates a unique fingerprint (hash) based on what's inside:
def calculate_hash(file_path):
    try:
        with open(file_path, "rb") as file: #Open the file
            file_content = file.read()
        return hashlib.sha256(file_content).hexdigest() #Making an active hash of the particular hash and its content.Run away if you see MD5 or SHA1.
    except FileNotFoundError:
        print(f"[Error] File '{file_path}' not found.")
        return None
    except Exception as e:
        print(f"[Error] Could not read file '{file_path}': {e}")
        return None

#It makes a fingerprint of the file. Checks it and tells you if itâ€™s clean or infected.
def scan_file(file_path, signatures):
    file_hash = calculate_hash(file_path) #Calculating the hash of the particular file.
    if file_hash is None:
        return None # Stop if file could not be read
    
    if file_hash in signatures:
        message = f"[!] Warning: File {file_path} is flagged as malicious!"
        
        #Make quarantine folder if it doesn't exist:
        os.makedirs(QUARANTINE_FOLDER, exist_ok=True)
        
        #Move the file into quarantine:
        quarantined_path = os.path.join(QUARANTINE_FOLDER, os.path.basename(file_path))
        try:
            shutil.move(file_path, quarantined_path)
            message += f" File moved to '{quarantined_path}'."
        except Exception as e:
            message += f" [Error] Could not move file to quarantine: {e}"
            
    else:
        message = f"[+] File {file_path} appears clean."   
        
    print(file_hash) #Shows the particular hash
    print(message)
    return file_hash, message        

#This is the robot scanning a whole pile of files one by one:
def scan_files(file_list, signatures):
    results = []
    total_files = len(file_list)
    for idx, file_path in enumerate(file_list, start=1):
        print(f"Scanning file {idx} of {total_files}: {file_path}")
        scan_result = scan_file(file_path, signatures)
        if scan_result:
            file_hash, message = scan_result
            print(f"Hash: {file_hash}")
            print(message)
            results.append((file_path, file_hash, message))
        else:
            results.append((file_path, None, "[Error] Scan Failed"))
    return results

#After scanning, the robot writes down what it found into a text file:
def save_results(results, output_file="scan_results.txt"):
    try:
        with open(output_file, "w") as f:
            for file_path, file_hash, message in results:
                f.write(f"File: {file_path}\n")
                if file_hash:
                    f.write(f"Hash: {file_hash}\n")
                f.write(f"Result: {message}\n")
                f.write("\n")
        print(f"\nScan results saved to {output_file}")
    except Exception as e:
        print(f"[Error] Could not save results to file: {e}")

#main function
#This is where the robot is told what to scan. You do this by typing something like:
#python MalwareDetection.py myfile.txt another_folder/
def main():
    #Check for command-line arguments for files/folder
    if len(sys.argv) < 2:
        print("Usage: python MalwareDetection.py <file_or_folder1> [file_or_folder2] ...")
        sys.exit(1)
        
    #Update malicious signatures online
    signatures = update_signatures(malicious_signatures)
        
    input_paths = sys.argv[1:]
    files_to_scan = []
        
    for path in input_paths:
        if os.path.isfile(path):
            files_to_scan.append(path)
        elif os.path.isdir(path):
            # Add all files in directory (non-recursive)
            for file_name in os.listdir(path):
                full_path = os.path.join(path, file_name)
                if os.path.isfile(full_path):
                    files_to_scan.append(full_path)
                    
        else:
            print(f"[Warning] Path '{path}' is neither a file nor a directory. Skipping.")
    
    if not files_to_scan:
        print("[Error] No valid files found to scan.")
        sys.exit(1)
        
    results = scan_files(files_to_scan, signatures)
    save_results(results)   
    
#Start of the script:
if __name__ == "__main__":
    main()

